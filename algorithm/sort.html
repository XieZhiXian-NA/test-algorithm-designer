<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
      //两数组之和a+b=sum 
      //时间复杂度为o(n) 少循环
      let a =[5,4,7,1,3,9,2,6]
      let num=10
      let obj={}
      for(let i=0;i<a.length;i++){
          if(a[i] in obj){
            //   console.log(`找到了[${a[i]},${obj[a[i]]}]`)
          }else{
              let need = num - a[i]
              obj[need] = a[i]
          }
      }  
    </script>

    <script>
      let arr =[5,4,7,1,3,9,2,6]
      // arr.find(value) o(n)
      //冒泡排序 o(n*n)
      function bubbleSort(arr){
          //遍历一次，如果你比你右边的高，则你们换位置，一次遍历以后，最右边的是最高的
          let len = arr.length-1
          for(let j=0;j<len;j++){
            for(let i=0;i<len-j;i++){
             if(arr[i]>arr[i+1]){
                 let tem = arr[i]
                 arr[i]=arr[i+1]
                 arr[i+1]=tem
             } 
          }
          }
          return arr
      }
      console.log(bubbleSort(arr))
    </script>

    <script>
    //快排 随便找一个数字，比他高的站右边，比他矮的站左边
    // 一次快排之后 将数组分成两部分 再对左右两个数组递归调用
    // nlog(n) 增长及其缓慢
      let ar =[5,4,7,1,3,9,2,6]
    

    //空间换时间 
    //   function quickSort(arr){
    //        //终止条件 arr.length=1 没有必要排序
    //        if(arr.length<=1){
    //            return arr
    //        }
    //         let flag = arr[0]
    //         let left=[]
    //         let right=[]
    //         //递归，就是规模缩小，有终止条件
    //         for(let i=1;i<arr.length;i++){
    //             if(arr[i]<flag){
    //                 left.push(arr[i])
    //       }else{
    //                 right.push(arr[i])
    //             }
    //         }
    //         return quickSort(left).concat([flag]).concat(quickSort(right))

    //   }
    //   console.log(quickSort(ar))
    //本地空间比较
    function quick_sort(arr){
        if(arr.length<=1){
            return arr
        }
        let flag = arr[0]
        let i = 1;
        let j =arr.length-1
        while(i<j){
            while(arr[j]>=flag && i<j){
                j--
            }
            while(arr[i]<=flag && i<j){
                i++
            }
            let temp = arr[i]
            arr[i]=arr[j]
            arr[j]=temp
        }
        let left = arr.slice(1,i+1)
        let right = arr.slice(j+1)
        return [...quick_sort(left),flag,...quick_sort(right)]
    }
     

    </script>

    <script>
    //二分算法 当遇到很大很大的数组--数据量特别大的时候
    let array =[1,2,3,4,5,6,7,8]
    function  binarySearch(arr,item){
          let i=0;
          let mid = null;
          let element = null
          let j=arr.length-1;
         //如果i=j 则向下取整为i
          while(i<=j){
               mid = Math.floor((i+j)/2)
               element = arr[mid]
              if(element==item){
                  return mid
              }
              if(element>item){
                 j = mid -1
              }else{
                  i=mid +1
              }
              mid=(i+j)/2
          }
          return -1
    }
    console.log(binarySearch(array,4))
    
    </script>
</body>
</html>