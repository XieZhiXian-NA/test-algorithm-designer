### 订阅/发布模式（观察者

> $on $emit
> 并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定的活动，并在状态改变后获得通知
> 订阅者因此也成为观察者，而被观察的对象成为发布者或者主题。
> 当发生了一个重要事件的时候，发布者会通知(调用)所有订阅者并且可能经常以事件对象的形式传递消息

```js
class Event{
    this.callbacks={
      '事件名':[
          'function1','function2'
      ]
  }
  $on()//增加事件
  $emit()//监听事件
}
```

### 单例模式 一个单一的模式

> 弹窗，无论点击多少次，弹窗只建立一次，闭包函数的变量缓存
> 保证一个类仅有一个实例，并提供一个访问它的全局访问点，先判断实例是否存在，如果存在则直接返回，如果不存在就创建再返回，这就确保了一个类只有一个实例对象

```js
let getSingle = function(fn) {
  let result;
  return function() {
    return result || (result = fn.apply(this, arguments));
  };
};
let createSingleLayer = getSingle(createLoginLayer);
document.getElementById("login-btn").onclick = function() {
  let loginLayer = createSingleLayer();
  loginLayer.style.display = "block";
};
```

## 装饰器模式

> 在不改变对象自身的基础上，在程序运行期间给对象动态添加方法。
> react 的高阶组件、react-redux 中的@connect
> ts 装饰器
> Element 的 el-input 对原生的 input 做一层装饰
> aop 面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 axios 拦截器

## 策略模式

> 表单验证,针对有要分很多种情况
> 定义一系列算法，将其封装起来，并且使他们可以相互替换
> 策略模式的目的就是将算法的使用和算法的实现分离开
> 一个基于策略模式的程序至少由两部分组成，
> --->1:一组策略类(可变) 策略类分装了具体的算法，并负责具体的计算过程。
> --->2:环境类 Context(不变) Context 接受客户的请求，随后将请求委托给某一给策略类。则说明 Context 中要维持对某个策略对象的引用
> 奖金计算 绩效为 S 的人年终奖 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，而绩效为 B 的人年终奖是 2 倍工资

## 代理模式

> 为一个对象使用占位符，以便控制对它的访问
> 常用的虚拟代理形式，某一个开销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建
> (使用虚拟代理实现图片懒加载)
> 图片懒加载的方式：先通过一张 loading 图占位，然后通过异步的方式加载图片，等图片加载好了以后再把完成的图片加载到 img 标签里
> 节流防抖 可以使用代理收集一段时间内的请求最后再一次性的发送给服务器

## 中介者模式

> 通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用。当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系
> 购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发 change 事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可
> redux,vuex 都属于中介者模式的实际应用，我们把共享的数据，抽离成一个单独的 store，每个都通过 store 这个中间件来操作对象
> 目的就是减少耦合

## 外观模式

> 让多个方法一起被调用
> 涉及到兼容性，参数支持多类型（string|Arrary），对外暴露统一的 API
> 组件库的设计

## 工厂模式

> 提供创建对象的借口，把成员对象的创建工作转交给一个外部对象，消除对象之间的耦合（相互影响）
> 弹窗，message 等对外提供的 api(function),都是调用另一个 api(弹窗类，message 类)，在对外提供的 api 里面新建一个弹窗或者 Message 的实例

## 建造者模式

> 参与了更多创建的过程 或者更复杂
> 不仅仅只是创建一个实例，还对实例的属性进行创建

## 迭代器模式

> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
> forEach,map

## 享元模式

> 用于性能优化的模式，运用共享技术来有效支持大量细粒度的对象。
> 如果系统中因为创建了大量类似的对象而导致内存占用过高。
> 内部状态存储于对象内部，并且可以被一些对象共享，独立于具体的场景，通常不会改变
> ----->$Message {success(){},error(){},warning(){}}都是每个对象都具有方法，都该被共享，绑定在对象的prototypes上 ，就是内部对象
> -----> 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享 Dailog(color,font)只在vue实例化时创建一次，通过this.$Message.success||error||warning 来改变，就不会创建过多的 Dialog 实例

## 职责连模式

> 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些接受对象连成一条链，并沿着这条链传递该请求，直到
> 有一个对象处理它为止。
> 中间件

## 模板方法

> 在一个方法中定义一个算法的骨架，而将着一些步骤的实现延迟到子类中。
> 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现
> slot children

## 备忘录模式 

>可以恢复到对象之前的某个状态
>react/redux时间旅行的功能
